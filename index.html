<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Sermon Transcript</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400&display=swap"
      rel="stylesheet"
    />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        background: #000;
        color: #fff;
        font-family: "Inter", system-ui, sans-serif;
        height: 100vh;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      #main {
        flex: 1;
        overflow-y: auto;
        padding: 60px 80px 7.5vh;
        will-change: scroll-position;
        -webkit-overflow-scrolling: touch;
      }

      /* Top-edge fade — fixed overlay so it never affects scroll compositing */
      body::after {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        height: 80px;
        background: linear-gradient(to bottom, #000, transparent);
        pointer-events: none;
        z-index: 10;
      }
      #main::-webkit-scrollbar {
        width: 0;
      }

      #empty {
        display: flex;
        align-items: center;
        justify-content: center;
        height: 100%;
        opacity: 0.12;
        font-size: 15px;
        font-weight: 300;
        letter-spacing: 2px;
        text-transform: uppercase;
      }

      /* Each segment block — fade in only, no translateY shift
         (vertical shift fights scroll positioning and causes jitter) */
      .entry {
        margin-bottom: var(--chunk-spacing, 60px);
        animation: fadeIn 0.45s ease forwards;
        opacity: 0;
      }
      @keyframes fadeIn {
        to {
          opacity: 1;
        }
      }

      /* Each sentence on its own line */
      .sentence {
        display: block;
        font-size: var(--sentence-size, 46px);
        line-height: 1.5;
        font-weight: 300;
        color: #fff;
        margin-bottom: var(--sentence-spacing, 20px);
      }
      .sentence:last-child {
        margin-bottom: 0;
      }
      .sentence[contenteditable="true"]:hover {
        outline: 1px solid #2a2a2a;
        outline-offset: 2px;
        border-radius: 2px;
      }
      .sentence[contenteditable="true"]:focus {
        outline: 1px solid #444;
        outline-offset: 3px;
        border-radius: 2px;
      }

      /* Scripture reference — inline, same size as sentences */
      .scripture-callout {
        display: block;
        font-size: var(--sentence-size, 46px);
        line-height: 1.5;
        font-weight: 300;
        color: #666;
        margin-bottom: var(--sentence-spacing, 20px);
      }

      /* Music / instrument detected */
      .music-label {
        display: block;
        margin-bottom: var(--chunk-spacing, 60px);
        font-size: 12px;
        letter-spacing: 3px;
        text-transform: uppercase;
        color: #666;
        animation: fadeIn 0.45s ease forwards;
        opacity: 0;
      }
      .music-label::before {
        content: "\266a\0020\0020";
      }

      /* Console toggle button - gear icon */
      #console-btn {
        position: fixed;
        bottom: 20px;
        right: 22px;
        background: none;
        border: none;
        color: #666;
        font-size: 22px;
        cursor: pointer;
        padding: 6px;
        transition: color 0.2s;
        z-index: 100;
        line-height: 1;
      }
      #console-btn:hover {
        color: #aaa;
      }

      /* Console drawer */
      #console-drawer {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: #0a0a0a;
        border-top: 1px solid #1e1e1e;
        transform: translateY(100%);
        transition: transform 0.25s ease;
        z-index: 99;
        display: flex;
        flex-direction: column;
        height: 40vh;
        min-height: 160px;
        max-height: 90vh;
      }
      #console-drawer.open {
        transform: translateY(0);
      }

      /* Resize handle */
      #resize-handle {
        height: 8px;
        cursor: ns-resize;
        background: transparent;
        border-bottom: 1px solid #1a1a1a;
        flex-shrink: 0;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      #resize-handle::after {
        content: "";
        width: 36px;
        height: 2px;
        background: #333;
        border-radius: 2px;
        margin-top: 1px;
        display: block;
      }
      #resize-handle:hover::after {
        background: #555;
      }

      #console-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 12px 20px;
        border-bottom: 1px solid #1a1a1a;
        flex-shrink: 0;
      }
      #console-header span {
        font-size: 10px;
        letter-spacing: 2px;
        text-transform: uppercase;
        color: #666;
      }

      #console-controls {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 14px 20px;
        border-bottom: 1px solid #1a1a1a;
        flex-shrink: 0;
        flex-wrap: wrap;
      }

      select {
        background: #111;
        border: 1px solid #2a2a2a;
        border-radius: 4px;
        padding: 7px 10px;
        color: #fff;
        font-family: "Inter", sans-serif;
        font-size: 12px;
        outline: none;
        cursor: pointer;
      }

      .btn {
        padding: 7px 18px;
        border-radius: 4px;
        border: 1px solid #2a2a2a;
        font-family: "Inter", sans-serif;
        font-size: 12px;
        cursor: pointer;
        transition: all 0.15s;
        white-space: nowrap;
        background: transparent;
      }
      .btn-start {
        background: #fff;
        color: #000;
        border-color: #fff;
      }
      .btn-start:hover {
        background: #ddd;
      }
      .btn-stop {
        color: #e55;
        border-color: #e55;
      }
      .btn-stop:hover {
        background: rgba(220, 50, 50, 0.08);
      }
      .btn-muted {
        color: #555;
      }
      .btn-muted:hover {
        color: #aaa;
        border-color: #666;
      }

      #log-panel {
        flex: 1;
        overflow-y: auto;
        padding: 10px 20px;
        -ms-overflow-style: none; /* Internet Explorer and Edge */
        scrollbar-width: none; /* Firefox */
      }
      #log-panel::-webkit-scrollbar {
        width: 2px;
      }
      #log-panel::-webkit-scrollbar-thumb {
        background: #222;
      }
      .log {
        font-family: monospace;
        font-size: 11px;
        line-height: 1.8;
        color: #3a3;
      }
      .log.err {
        color: #e55;
      }
      .log.warn {
        color: #b83;
      }
      .log.info {
        color: #48f;
      }

      /* Remote control bar (phone view) */
      /* Remote status indicator */
      .remote-status {
        font-size: 10px;
        letter-spacing: 2px;
        text-transform: uppercase;
      }
      .remote-status.live {
        color: #3a3;
      }
      .remote-status.ready {
        color: #555;
      }
      .remote-status.offline {
        color: #e55;
      }

      #toast {
        position: fixed;
        bottom: 50px;
        left: 50%;
        transform: translateX(-50%);
        background: #1a0000;
        color: #faa;
        padding: 10px 18px;
        border-radius: 4px;
        font-size: 12px;
        max-width: 400px;
        display: none;
        z-index: 999;
        border: 1px solid #500;
        text-align: center;
        line-height: 1.5;
      }

      /* Typography controls */
      .control-group {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 0 4px;
        border-left: 1px solid #1e1e1e;
      }
      .control-group:first-child {
        border-left: none;
      }
      .control-label {
        font-size: 10px;
        letter-spacing: 1px;
        text-transform: uppercase;
        color: #555;
        white-space: nowrap;
      }
      .slider {
        -webkit-appearance: none;
        width: 80px;
        height: 3px;
        background: #2a2a2a;
        border-radius: 2px;
        outline: none;
        cursor: pointer;
      }
      .slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: #888;
        cursor: pointer;
        transition: background 0.15s;
      }
      .slider::-webkit-slider-thumb:hover {
        background: #bbb;
      }
      /* Firefox slider thumb */
      .slider::-moz-range-thumb {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: #888;
        border: none;
        cursor: pointer;
        transition: background 0.15s;
      }
      .slider::-moz-range-thumb:hover {
        background: #bbb;
      }

      input[type="number"],
      input[type="text"] {
        background: #111;
        border: 1px solid #2a2a2a;
        border-radius: 4px;
        padding: 5px 8px;
        color: #fff;
        font-size: 12px;
        outline: none;
        font-family: "Inter", sans-serif;
      }
      input[type="number"] {
        width: 56px;
        -moz-appearance: textfield;
      }
      input[type="number"]::-webkit-inner-spin-button {
        opacity: 0.4;
      }
      #sermon-title-input,
      #remote-sermon-title-input {
        width: 160px;
      }

      /* Sermon title — styled identically to transcript sentences */
      #sermon-title-display {
        display: none;
        font-size: var(--sentence-size, 46px);
        line-height: 1.5;
        font-weight: 300;
        color: #fff;
        margin-bottom: var(--sentence-spacing, 20px);
      }
    </style>
  </head>
  <body>
    <div id="main">
      <div id="empty">Waiting for sermon&hellip;</div>
      <div id="sermon-title-display"></div>
      <div id="transcript"></div>
    </div>

    <button id="console-btn" onclick="toggleConsole()" title="Admin Console">
      &#9881;
    </button>

    <div id="console-drawer">
      <div id="resize-handle"></div>
      <div id="console-header">
        <span>Admin Console</span>
        <span
          id="queue-depth"
          style="
            font-size: 10px;
            letter-spacing: 1px;
            text-transform: uppercase;
            margin-left: auto;
            margin-right: 16px;
          "
        ></span>
        <button
          class="btn btn-muted"
          style="padding: 4px 10px; font-size: 11px"
          onclick="popOutConsole()"
          title="Pop out console"
        >
          &#8599;
        </button>
        <button
          class="btn btn-muted"
          style="padding: 4px 10px; font-size: 11px"
          onclick="toggleConsole()"
        >
          Close
        </button>
      </div>
      <div id="console-controls">
        <div class="control-group">
          <button class="btn btn-start" id="btn-start" onclick="startSession()">
            &#9654; Begin
          </button>
          <button
            class="btn btn-stop"
            id="btn-stop"
            onclick="stopSession()"
            style="display: none"
          >
            &#9632; Stop
          </button>
          <button class="btn btn-muted" id="btn-mute" onclick="toggleMute()">
            Mute
          </button>
          <button class="btn btn-muted" onclick="clearAll()">Clear</button>
          <button
            class="btn btn-muted"
            onclick="downloadTranscript('Manual download')"
          >
            &#8595; Download
          </button>
        </div>
        <div class="control-group">
          <span class="control-label">Title</span>
          <input
            type="text"
            id="sermon-title-input"
            placeholder="Sermon title&hellip;"
            oninput="setSermonTitle(this.value)"
          />
        </div>
        <div class="control-group">
          <span class="control-label">Segment</span>
          <select id="chunk-ms" onchange="pushTypoSync()">
            <option value="20000" selected>20s</option>
            <option value="25000">25s</option>
            <option value="30000">30s</option>
          </select>
        </div>
        <div class="control-group">
          <span class="control-label">Size</span>
          <input
            type="range"
            class="slider"
            id="font-size-slider"
            min="24"
            max="175"
            value="46"
            oninput="
              applyTypographyLocal(this.value, null);
              document.getElementById('font-size-input').value = this.value;
            "
            onchange="applyTypography()"
          />
          <input
            type="number"
            id="font-size-input"
            min="24"
            max="175"
            value="46"
            oninput="
              applyTypographyLocal(this.value, null);
              document.getElementById('font-size-slider').value = this.value;
            "
            onchange="applyTypography()"
          />
        </div>
        <div class="control-group">
          <span class="control-label">Line</span>
          <input
            type="range"
            class="slider"
            id="line-height-slider"
            min="12"
            max="150"
            value="20"
            oninput="
              applyTypographyLocal(null, this.value, null);
              document.getElementById('line-height-input').value = this.value;
            "
            onchange="applyTypography()"
          />
          <input
            type="number"
            id="line-height-input"
            min="12"
            max="150"
            value="20"
            oninput="
              applyTypographyLocal(null, this.value, null);
              document.getElementById('line-height-slider').value = this.value;
            "
            onchange="applyTypography()"
          />
        </div>
        <div class="control-group">
          <span class="control-label">Chunk</span>
          <input
            type="range"
            class="slider"
            id="chunk-spacing-slider"
            min="10"
            max="200"
            value="60"
            oninput="
              applyTypographyLocal(null, null, this.value);
              document.getElementById('chunk-spacing-input').value = this.value;
            "
            onchange="applyTypography()"
          />
          <input
            type="number"
            id="chunk-spacing-input"
            min="10"
            max="200"
            value="60"
            oninput="
              applyTypographyLocal(null, null, this.value);
              document.getElementById('chunk-spacing-slider').value = this.value;
            "
            onchange="applyTypography()"
          />
        </div>
        <div class="control-group">
          <span class="control-label">Scroll</span>
          <input
            type="range"
            class="slider"
            id="scroll-speed-slider"
            min="40"
            max="500"
            value="70"
            oninput="
              scrollSpeed = parseInt(this.value);
              _lastLocalTypoTime = Date.now();
              document.getElementById('scroll-speed-input').value = this.value;
            "
            onchange="updateScrollSpeed()"
          />
          <input
            type="number"
            id="scroll-speed-input"
            min="40"
            max="500"
            value="70"
            oninput="
              scrollSpeed = parseInt(this.value);
              _lastLocalTypoTime = Date.now();
              document.getElementById('scroll-speed-slider').value = this.value;
            "
            onchange="updateScrollSpeed()"
          />
          <button
            class="btn btn-muted"
            id="btn-follow"
            onclick="resumeAutoScroll()"
            style="
              display: none;
              padding: 4px 10px;
              font-size: 11px;
              margin-left: 4px;
            "
          >
            &#8615; Follow
          </button>
        </div>
      </div>
      <div id="log-panel">
        <div id="log-entries"></div>
      </div>
    </div>

    <div id="toast"></div>

    <script>
      // ═══════════════════════════════════════════════════════════════
      //  SERMON TRANSLATOR — Real-time Korean → English display
      //
      //  Architecture:
      //    Laptop (main)           Cloud (Redis)            Phone (remote)
      //    ─────────────           ─────────────            ──────────────
      //    Mic → Groq Whisper      Stores transcript,       Polls every 1.5s
      //    → Claude Sonnet         state, typography,       Shows transcript
      //    → Render on screen      edits, commands          + admin controls
      //    Pushes entries ───────► ◄─────────────── Sends commands
      //    Polls every 3s ───────► ◄─────────────── Polls every 1.5s
      //
      //  Pipeline per 30s chunk:
      //    Record audio → Groq Whisper (KO STT, ~3s) → Claude (KO→EN, ~5s) → Render
      //
      //  Key design:
      //    - Chunks queued & processed one-at-a-time to preserve sermon order
      //    - Grace period prevents polls from overwriting mid-drag slider values
      //    - Bigram-frequency filter catches Whisper hallucinations on silence
      //    - Incremental Haiku summary keeps Claude context bounded over long sermons
      //    - Single sync-pull endpoint returns all state (entries, edits, typo, commands)
      // ═══════════════════════════════════════════════════════════════

      // ════════════════════════════════════════════════════════════
      //  SCROLL — pure teleprompter
      //  Always scrolls at a constant scrollSpeed px/s — no snapping,
      //  no jumping.  The loop stays alive while there's content below;
      //  when new text arrives, the loop just keeps going.
      // ════════════════════════════════════════════════════════════
      var autoScroll = true;
      var scrollSpeed = 70; // pixels per second
      var _scrollRAF = null;
      var _scrollLock = false;
      var _scrollTarget = 0;
      var _scrollLastT = 0;
      var _scrollSubPx = 0;
      var _lastLocalTypoTime = 0;
      var SCROLL_FILL_THRESHOLD = 0.65; // content must fill 65% of viewport to auto-scroll

      // True when transcript content is tall enough to warrant scrolling
      function _contentFillsViewport() {
        var transcript = document.getElementById("transcript");
        var main = document.getElementById("main");
        return (
          transcript.offsetHeight >= main.clientHeight * SCROLL_FILL_THRESHOLD
        );
      }

      function _scrollStep(now) {
        var main = document.getElementById("main");
        var dt = (now - _scrollLastT) / 1000;
        _scrollLastT = now;
        if (dt > 0.1) dt = 0.1;

        // Not enough content yet — stay alive but don't move
        if (!_contentFillsViewport()) {
          _scrollLock = false;
          _scrollRAF = requestAnimationFrame(_scrollStep);
          return;
        }

        var maxScroll = main.scrollHeight - main.clientHeight;
        var remaining = maxScroll - main.scrollTop;
        _scrollTarget = maxScroll;

        if (remaining < 1) {
          // At the bottom — keep loop alive so new content is picked up
          _scrollLock = false;
          _scrollRAF = requestAnimationFrame(_scrollStep);
          return;
        }

        _scrollLock = true;

        // Constant speed, never overshoot
        var move = Math.min(scrollSpeed * dt, remaining);

        _scrollSubPx += move;
        var intMove = Math.floor(_scrollSubPx);
        if (intMove >= 1) {
          main.scrollTop += intMove;
          _scrollSubPx -= intMove;
        }

        _scrollRAF = requestAnimationFrame(_scrollStep);
      }

      // Ensure the scroll loop is running (idempotent)
      function scrollToBottom() {
        if (document.activeElement && document.activeElement.isContentEditable)
          return;
        if (!autoScroll) return;
        if (_scrollRAF) return; // already running

        _scrollLastT = performance.now();
        _scrollSubPx = 0;
        _scrollRAF = requestAnimationFrame(_scrollStep);
      }

      // Stop the teleprompter loop (user grabbed the scroll)
      function cancelScrollAnim() {
        if (_scrollRAF) {
          cancelAnimationFrame(_scrollRAF);
          _scrollRAF = null;
        }
        _scrollLock = false;
        _scrollSubPx = 0;
      }

      // Follow button — snap to bottom immediately
      function resumeAutoScroll() {
        cancelScrollAnim();
        autoScroll = true;
        updateFollowBtn();
        _scrollLock = true;
        var main = document.getElementById("main");
        main.scrollTop = main.scrollHeight - main.clientHeight;
        requestAnimationFrame(function () {
          _scrollLock = false;
        });
      }

      function toggleMute() {
        isMuted = !isMuted;
        updateMuteBtn();
        log(
          isMuted ? "Muted — audio will be discarded." : "Unmuted.",
          isMuted ? "warn" : "info",
        );
        pushSync("state", {
          isListening: isListening,
          isMuted: isMuted,
          chunkMs: parseInt(document.getElementById("chunk-ms").value),
        });
      }

      function updateMuteBtn() {
        var btn = document.getElementById("btn-mute");
        if (btn) {
          btn.textContent = isMuted ? "\u25a0 Unmute" : "Mute";
          btn.style.color = isMuted ? "#e55" : "";
          btn.style.borderColor = isMuted ? "#e55" : "";
        }
        // Remote mute button reflects current state
        var rbtn = document.getElementById("remote-mute");
        if (rbtn) {
          rbtn.textContent = isMuted ? "\u25a0 Unmute" : "Mute";
          rbtn.style.color = isMuted ? "#e55" : "";
          rbtn.style.borderColor = isMuted ? "#e55" : "";
        }
      }

      function updateFollowBtn() {
        var btn = document.getElementById("btn-follow");
        if (btn) btn.style.display = autoScroll ? "none" : "inline-block";
        var rbtn = document.getElementById("remote-follow");
        if (rbtn) rbtn.style.display = autoScroll ? "none" : "inline-block";
      }

      function updateScrollSpeed() {
        scrollSpeed = parseInt(
          document.getElementById("scroll-speed-input").value,
        );
        pushTypoSync();
      }

      // ════════════════════════════════════════════════════════════
      //  STATE
      // ════════════════════════════════════════════════════════════
      // ════════════════════════════════════════════════════════════
      //  AUTH — one-time password per browser session
      // ════════════════════════════════════════════════════════════
      var adminKey = sessionStorage.getItem("adminKey") || "";

      function authHeaders() {
        return { "Content-Type": "application/json", "x-admin-key": adminKey };
      }

      function showAuthGate() {
        var overlay = document.createElement("div");
        overlay.id = "auth-overlay";
        overlay.setAttribute("style",
          "position:fixed;inset:0;z-index:9999;background:#000;" +
          "display:flex;align-items:center;justify-content:center;flex-direction:column;gap:16px;"
        );
        overlay.innerHTML =
          '<div style="color:#888;font-size:14px;letter-spacing:1px;margin-bottom:8px">THE LORD\'S CHURCH</div>' +
          '<input id="auth-input" type="password" placeholder="Enter admin key\u2026" autofocus ' +
          'style="background:#111;border:1px solid #333;border-radius:6px;padding:12px 18px;' +
          'color:#fff;font-size:16px;width:260px;text-align:center;outline:none">' +
          '<div id="auth-error" style="color:#e55;font-size:13px;height:18px"></div>';
        document.body.appendChild(overlay);

        var input = document.getElementById("auth-input");
        input.addEventListener("keydown", function (e) {
          if (e.key !== "Enter") return;
          var val = input.value.trim();
          if (!val) return;
          // Test the key against a lightweight endpoint
          adminKey = val;
          fetch("/api/sync-pull?since=0", { headers: { "x-admin-key": val } })
            .then(function (r) {
              if (r.ok) {
                sessionStorage.setItem("adminKey", val);
                overlay.remove();
              } else {
                adminKey = "";
                document.getElementById("auth-error").textContent = "Invalid key";
                input.value = "";
                input.focus();
              }
            })
            .catch(function () {
              document.getElementById("auth-error").textContent = "Connection error";
            });
        });
      }

      // Gate everything behind auth — if no stored key, show prompt
      if (!adminKey) {
        document.addEventListener("DOMContentLoaded", showAuthGate);
      }

      var isRemote = location.search.indexOf("remote") !== -1; // ?remote in URL = phone view
      var sermonTitle = "";
      var isMuted = false; // when true, audio chunks are discarded before Groq

      let mediaRecorder = null;
      let audioChunks = [];
      let isListening = false; // session active (mic open)
      let micStream = null;
      let chunkTimer = null;
      let queue = []; // audio blobs waiting to be processed (FIFO)
      let busy = false; // true while a chunk is going through the pipeline
      let consoleOpen = false;
      let logHistory = []; // last 100 log entries, replayed into popup on open
      let consoleWindow = null; // reference to detached popup window

      const WINDOW_SIZE = 3; // recent segments sent as context to Claude (~60% fewer tokens than 8)
      const SUMMARY_EVERY = 8; // Haiku summarises every N segments
      let recentSegments = []; // sliding window of { korean, english }
      let allSegments = []; // full sermon history (for summary generation)
      let sermonSummary = ""; // rolling 3-sentence summary from Haiku
      let summarizing = false;
      let lastEnglishTail = ""; // tail of previous translation for continuity

      // ════════════════════════════════════════════════════════════
      //  SERMON TITLE
      // ════════════════════════════════════════════════════════════

      // Apply a title coming from sync (no push)
      function applySermonTitle(title) {
        sermonTitle = title || "";
        var displayEl = document.getElementById("sermon-title-display");
        if (displayEl) {
          displayEl.textContent = sermonTitle ? "Sermon Title: " + sermonTitle : "";
          displayEl.style.display = sermonTitle ? "block" : "none";
        }
        if (sermonTitle) {
          document.getElementById("empty").style.display = "none";
        }
        // Sync inputs without re-triggering oninput
        ["sermon-title-input", "remote-sermon-title-input"].forEach(
          function (id) {
            var el = document.getElementById(id);
            if (el && el !== document.activeElement) el.value = sermonTitle;
          },
        );
      }

      // Called from user input — applies + pushes to Redis
      // If Korean is detected, auto-translates after a short debounce.
      var _titleTranslateTimer = null;
      var _titleTranslateVersion = 0;

      function setSermonTitle(title) {
        applySermonTitle(title);
        pushTypoSync();

        // Auto-translate if Korean characters detected
        if (/[\uAC00-\uD7AF\u1100-\u11FF\u3130-\u318F]/.test(title)) {
          clearTimeout(_titleTranslateTimer);
          _titleTranslateTimer = setTimeout(function () {
            translateTitle(title);
          }, 600);
        }
      }

      async function translateTitle(koreanTitle) {
        var myVersion = ++_titleTranslateVersion;
        try {
          var resp = await fetch("/api/claude", {
            method: "POST",
            headers: authHeaders(),
            body: JSON.stringify({
              model: "claude-sonnet-4-20250514",
              max_tokens: 100,
              temperature: 0,
              system:
                "You are translating a Korean sermon title to English for a Christian church service at The Lord's Church in Iselin, New Jersey. Translate naturally and fluently. Return ONLY the English translation, nothing else.",
              messages: [{ role: "user", content: koreanTitle }],
            }),
          });
          if (!resp.ok || myVersion !== _titleTranslateVersion) return;
          var data = await resp.json();
          var english = data.content
            .map(function (b) {
              return b.text || "";
            })
            .join("")
            .trim();
          if (english && myVersion === _titleTranslateVersion) {
            applySermonTitle(english);
            pushTypoSync();
          }
        } catch (e) {
          console.warn("[title translate]", e);
        }
      }

      // ════════════════════════════════════════════════════════════
      //  CONSOLE
      // ════════════════════════════════════════════════════════════
      function toggleConsole() {
        if (consoleWindow && !consoleWindow.closed) {
          consoleWindow.focus();
          return;
        }
        consoleOpen = !consoleOpen;
        document
          .getElementById("console-drawer")
          .classList.toggle("open", consoleOpen);
        if (consoleOpen) document.getElementById("log-panel").scrollTop = 99999;
      }

      function log(msg, cls) {
        cls = cls || "";
        var text =
          "[" +
          new Date().toLocaleTimeString("en-US", { hour12: false }) +
          "] " +
          msg;

        logHistory.push({ text: text, cls: cls });
        if (logHistory.length > 100) logHistory.shift();

        if (consoleWindow && !consoleWindow.closed) {
          consoleWindow.addLog(text, cls);
        }

        const wrap = document.getElementById("log-entries");
        const el = document.createElement("div");
        el.className = "log " + cls;
        el.textContent = text;
        wrap.appendChild(el);
        while (wrap.children.length > 150) wrap.removeChild(wrap.firstChild);
        if (consoleOpen) document.getElementById("log-panel").scrollTop = 99999;
      }

      function updateQueueDepth() {
        var el = document.getElementById("queue-depth");
        if (!el) return;
        var n = queue.length;
        el.textContent = n ? "Queue: " + n + " pending" : "";
        el.style.color = n > 2 ? "#e55" : "#b83";
        if (consoleWindow && !consoleWindow.closed) {
          consoleWindow.setQueue(n);
        }
      }

      function toast(msg) {
        const el = document.getElementById("toast");
        el.textContent = msg;
        el.style.display = "block";
        clearTimeout(window._tt);
        window._tt = setTimeout(function () {
          el.style.display = "none";
        }, 7000);
      }

      // ════════════════════════════════════════════════════════════
      //  SYNC — bidirectional state sync via Upstash Redis
      //  Laptop pushes entries/state; phone pushes commands/edits.
      //  Both poll sync-pull for typography, edits, and commands.
      //  Typography uses a 1.5s grace period to prevent polls from
      //  overwriting in-progress slider drags.
      // ════════════════════════════════════════════════════════════

      // ── Typography sync (all devices) ────────────────────────────
      // Small debounce so rapid onchange bursts don't spam Redis
      var _typoTimer = null;
      function pushTypoSync() {
        _lastLocalTypoTime = Date.now();
        clearTimeout(_typoTimer);
        _typoTimer = setTimeout(function () {
          // Read from the ACTIVE slider for this page mode.
          // On remote, the main sliders exist but are hidden (display:none)
          // and retain stale default values — so we must prefer remote sliders.
          var fsEl = isRemote
            ? document.getElementById("remote-font-slider") ||
              document.getElementById("font-size-slider")
            : document.getElementById("font-size-slider") ||
              document.getElementById("remote-font-slider");
          var lhEl = isRemote
            ? document.getElementById("remote-spacing-slider") ||
              document.getElementById("line-height-slider")
            : document.getElementById("line-height-slider") ||
              document.getElementById("remote-spacing-slider");
          var fontSize = fsEl ? parseInt(fsEl.value) : 46;
          var lineHeight = lhEl ? parseInt(lhEl.value) : 20;
          var chunkEl =
            document.getElementById("chunk-ms") ||
            document.getElementById("remote-chunk-ms");
          var chunkMs = chunkEl ? parseInt(chunkEl.value) : 30000;
          var csEl = isRemote
            ? document.getElementById("remote-chunk-spacing-slider") ||
              document.getElementById("chunk-spacing-slider")
            : document.getElementById("chunk-spacing-slider") ||
              document.getElementById("remote-chunk-spacing-slider");
          var chunkSpacing = csEl ? parseInt(csEl.value) : 60;
          fetch("/api/sync-push", {
            method: "POST",
            headers: authHeaders(),
            body: JSON.stringify({
              type: "typo",
              data: {
                fontSize: fontSize,
                lineHeight: lineHeight,
                chunkSpacing: chunkSpacing,
                scrollSpeed: scrollSpeed,
                chunkMs: chunkMs,
                sermonTitle: sermonTitle,
              },
            }),
          }).catch(function (e) {
            console.warn("[typo sync]", e);
          });
        }, 300);
      }

      // Apply incoming typography to this device — updates CSS vars + all input UIs
      function applyTypoState(typo) {
        if (!typo) return;
        // Skip if this device is actively editing (prevents poll overwriting a drag in progress)
        if (Date.now() - _lastLocalTypoTime < 1500) return;
        if (typo.fontSize) {
          document.documentElement.style.setProperty(
            "--sentence-size",
            typo.fontSize + "px",
          );
          var fs = document.getElementById("font-size-input");
          if (fs) fs.value = typo.fontSize;
          var fss = document.getElementById("font-size-slider");
          if (fss) fss.value = typo.fontSize;
          var rfs = document.getElementById("remote-font-input");
          if (rfs) rfs.value = typo.fontSize;
          var rfss = document.getElementById("remote-font-slider");
          if (rfss) rfss.value = typo.fontSize;
        }
        if (typo.lineHeight) {
          document.documentElement.style.setProperty(
            "--sentence-spacing",
            typo.lineHeight + "px",
          );
          var lh = document.getElementById("line-height-input");
          if (lh) lh.value = typo.lineHeight;
          var lhs = document.getElementById("line-height-slider");
          if (lhs) lhs.value = typo.lineHeight;
          var rlh = document.getElementById("remote-spacing-input");
          if (rlh) rlh.value = typo.lineHeight;
          var rlhs = document.getElementById("remote-spacing-slider");
          if (rlhs) rlhs.value = typo.lineHeight;
        }
        if (typo.chunkSpacing) {
          document.documentElement.style.setProperty(
            "--chunk-spacing",
            typo.chunkSpacing + "px",
          );
          var csi = document.getElementById("chunk-spacing-input");
          if (csi) csi.value = typo.chunkSpacing;
          var css2 = document.getElementById("chunk-spacing-slider");
          if (css2) css2.value = typo.chunkSpacing;
          var rcsi = document.getElementById("remote-chunk-spacing-input");
          if (rcsi) rcsi.value = typo.chunkSpacing;
          var rcss = document.getElementById("remote-chunk-spacing-slider");
          if (rcss) rcss.value = typo.chunkSpacing;
        }
        if (typo.scrollSpeed) {
          scrollSpeed = typo.scrollSpeed;
          var ss = document.getElementById("scroll-speed-input");
          if (ss) ss.value = typo.scrollSpeed;
          var sss = document.getElementById("scroll-speed-slider");
          if (sss) sss.value = typo.scrollSpeed;
          var rss = document.getElementById("remote-scroll-input");
          if (rss) rss.value = typo.scrollSpeed;
          var rsss = document.getElementById("remote-scroll-slider");
          if (rsss) rsss.value = typo.scrollSpeed;
        }
        if (typo.chunkMs) {
          var cm = document.getElementById("chunk-ms");
          if (cm) cm.value = typo.chunkMs;
          var rcm = document.getElementById("remote-chunk-ms");
          if (rcm) rcm.value = typo.chunkMs;
        }
        if (typo.sermonTitle !== undefined) {
          applySermonTitle(typo.sermonTitle);
        }
      }

      // ── Laptop side ──────────────────────────────────────────────
      function pushSync(type, data) {
        if (isRemote) return;
        fetch("/api/sync-push", {
          method: "POST",
          headers: authHeaders(),
          body: JSON.stringify({ type: type, data: data }),
        }).catch(function () {}); // fire-and-forget; never block main flow
      }

      // Laptop polls sync-pull for commands + edits + typography in ONE fetch.
      // Uses since=9999999999999 to skip transcript entries (laptop already has them).
      var lastCommandId = Date.now(); // ignore stale commands from before this page load
      async function pollCommands() {
        if (isRemote) return;
        try {
          var resp = await fetch(
            "/api/sync-pull?since=9999999999999&sinceEdit=" + lastEditId,
            { headers: { "x-admin-key": adminKey } },
          );
          if (!resp.ok) return;
          var data = await resp.json();

          // Process remote commands (start, stop, mute, clear, setChunkMs)
          var cmd = data.command;
          if (cmd && cmd.command && cmd.id && cmd.id > lastCommandId) {
            lastCommandId = cmd.id;
            if (cmd.command === "start" && !isListening) startSession();
            else if (cmd.command === "stop" && isListening) stopSession();
            else if (cmd.command === "clear") clearAll();
            else if (cmd.command === "mute" && !isMuted) toggleMute();
            else if (cmd.command === "unmute" && isMuted) toggleMute();
            else if (cmd.command === "setChunkMs" && cmd.value) {
              var sel = document.getElementById("chunk-ms");
              if (sel) sel.value = cmd.value;
            }
          }

          // Apply remote edits and typography
          (data.edits || []).forEach(function (edit) {
            if (edit.id > lastEditId) lastEditId = edit.id;
            applyEdit(edit);
          });
          applyTypoState(data.typo);
        } catch (_) {}
      }

      // ── Remote (phone) side ──────────────────────────────────────
      var lastEntryId = 0;
      var lastEditId = 0;
      var lastClearedAt = 0;

      async function pollRemote() {
        try {
          var resp = await fetch(
            "/api/sync-pull?since=" + lastEntryId + "&sinceEdit=" + lastEditId,
            { headers: { "x-admin-key": adminKey } },
          );
          if (!resp.ok) {
            setRemoteStatus("offline");
            return;
          }
          var data = await resp.json();

          if (data.state) updateRemoteState(data.state);

          var newEntries = false;
          (data.entries || []).forEach(function (entry) {
            if (entry.id > lastEntryId) lastEntryId = entry.id;
            renderRemoteEntry(entry);
            newEntries = true;
          });
          if (newEntries) scrollToBottom();

          (data.edits || []).forEach(function (edit) {
            if (edit.id > lastEditId) lastEditId = edit.id;
            applyEdit(edit);
          });

          applyTypoState(data.typo);
          setRemoteStatus(
            data.state && data.state.isListening ? "live" : "ready",
          );
        } catch (_) {
          setRemoteStatus("offline");
        }
      }

      function setRemoteStatus(status) {
        var el = document.getElementById("remote-status");
        if (!el) return;
        el.className = "remote-status " + status;
        el.textContent =
          status === "live"
            ? "\u25cf Live"
            : status === "offline"
              ? "\u25cb Offline"
              : "\u25cb Ready";
      }

      function updateRemoteState(state) {
        var btnStart = document.getElementById("remote-start");
        var btnStop = document.getElementById("remote-stop");
        if (!btnStart || !btnStop) return;
        btnStart.style.display = state.isListening ? "none" : "inline-block";
        btnStop.style.display = state.isListening ? "inline-block" : "none";
        document.getElementById("empty").style.display =
          state.isListening || sermonTitle ? "none" : "";
        if (state.isMuted !== undefined) {
          isMuted = state.isMuted;
          updateMuteBtn();
        }

        // Laptop called clearAll — wipe phone DOM too
        if (state.clearedAt && state.clearedAt > lastClearedAt) {
          lastClearedAt = state.clearedAt;
          lastEntryId = 0;
          lastEditId = 0;
          document.getElementById("transcript").innerHTML = "";
          if (!sermonTitle) document.getElementById("empty").style.display = "";
        }
      }

      async function sendCommand(command, value) {
        try {
          var payload = { command: command, id: Date.now() };
          if (value !== undefined) payload.value = value;
          await fetch("/api/sync-command", {
            method: "POST",
            headers: authHeaders(),
            body: JSON.stringify(payload),
          });
        } catch (_) {}
      }

      // Push an edit from either device — no isRemote guard
      function pushEdit(entryId, sentences) {
        fetch("/api/sync-push", {
          method: "POST",
          headers: authHeaders(),
          body: JSON.stringify({
            type: "editEntry",
            data: { id: Date.now(), entryId: entryId, sentences: sentences },
          }),
        }).catch(function () {});
      }

      // Attach blur listeners to an entry's sentences so edits sync to the other device
      function addEditListeners(entryEl, entryId) {
        entryEl.querySelectorAll(".sentence").forEach(function (span) {
          span.addEventListener("blur", function () {
            var texts = Array.from(entryEl.querySelectorAll(".sentence")).map(
              function (s) {
                return s.textContent.trim();
              },
            );
            pushEdit(entryId, texts);
          });
        });
      }

      // Apply an incoming edit to the matching entry in the local DOM
      function applyEdit(edit) {
        var entryEl = document.querySelector(
          '[data-entry-id="' + edit.entryId + '"]',
        );
        if (!entryEl) return;
        var spans = entryEl.querySelectorAll(".sentence");
        (edit.sentences || []).forEach(function (text, i) {
          if (spans[i] && document.activeElement !== spans[i]) {
            spans[i].textContent = text;
          }
        });
      }

      function renderRemoteEntry(entry) {
        // Skip if already rendered (prevents double-render on rapid back-to-back polls)
        if (
          entry.id &&
          document.querySelector('[data-entry-id="' + entry.id + '"]')
        )
          return;
        document.getElementById("empty").style.display = "none";
        var wrap = document.getElementById("transcript");

        if (entry.type === "music") {
          var label = document.createElement("div");
          label.className = "music-label";
          label.textContent = entry.description;
          wrap.appendChild(label);
        } else {
          var div = document.createElement("div");
          div.className = "entry";
          div.dataset.entryId = String(entry.id);
          var html = (entry.sentences || [])
            .map(function (s) {
              return (
                '<span class="sentence" contenteditable="true">' +
                esc(s) +
                "</span>"
              );
            })
            .join("");
          if (entry.scripture && entry.scripture.length) {
            html += entry.scripture
              .filter(function (sc) {
                return sc.ref;
              })
              .map(function (sc) {
                return (
                  '<span class="scripture-callout">(' +
                  esc(sc.ref) +
                  (sc.note ? " \u2014 " + esc(sc.note) : "") +
                  ")</span>"
                );
              })
              .join("");
          }
          div.innerHTML = html;
          wrap.appendChild(div);
          addEditListeners(div, entry.id);
        }
      }

      var remotePanelOpen = false;

      function toggleRemotePanel() {
        remotePanelOpen = !remotePanelOpen;
        var panel = document.getElementById("remote-panel");
        var main = document.getElementById("main");
        if (!panel) return;
        if (remotePanelOpen) {
          panel.style.display = "flex";
          requestAnimationFrame(function () {
            main.style.paddingTop = panel.offsetHeight + 8 + "px";
          });
        } else {
          panel.style.display = "none";
          main.style.paddingTop = "0";
        }
      }

      function updateRemoteScrollSpeed(val) {
        scrollSpeed = parseInt(val);
        pushTypoSync();
      }

      function initRemote() {
        // Hide laptop-only chrome
        document.getElementById("console-btn").style.display = "none";
        document.getElementById("console-drawer").style.display = "none";

        // Full-height transcript (no top bar by default)
        document.documentElement.style.setProperty("--sentence-size", "46px");
        document.documentElement.style.setProperty(
          "--sentence-spacing",
          "20px",
        );

        // Subtle gear toggle button — always visible, top-right
        var togBtn = document.createElement("button");
        togBtn.title = "Admin Controls";
        togBtn.innerHTML = "&#9881;";
        togBtn.setAttribute(
          "style",
          "position:fixed;top:14px;right:16px;z-index:300;" +
            "background:rgba(10,10,10,0.7);border:1px solid #222;border-radius:4px;" +
            "color:#444;font-size:18px;cursor:pointer;padding:5px 8px;line-height:1;" +
            "transition:color 0.2s;",
        );
        togBtn.addEventListener("mouseenter", function () {
          togBtn.style.color = "#aaa";
        });
        togBtn.addEventListener("mouseleave", function () {
          togBtn.style.color = "#444";
        });
        togBtn.addEventListener("click", toggleRemotePanel);
        document.body.appendChild(togBtn);

        // Collapsible control panel (hidden by default)
        var panel = document.createElement("div");
        panel.id = "remote-panel";
        panel.setAttribute(
          "style",
          "position:fixed;top:0;left:0;right:0;z-index:200;" +
            "background:#0a0a0a;border-bottom:1px solid #1e1e1e;" +
            "padding:14px 20px 16px;display:none;flex-direction:column;gap:12px;",
        );
        panel.innerHTML =
          // Row 1: status + session controls
          '<div style="display:flex;align-items:center;gap:10px;flex-wrap:wrap">' +
          '<span id="remote-status" class="remote-status offline">&#9675; Connecting&#x2026;</span>' +
          '<button class="btn btn-start" id="remote-start" onclick="sendCommand(\'start\')">&#9654; Begin</button>' +
          '<button class="btn btn-stop"  id="remote-stop"  onclick="sendCommand(\'stop\')"  style="display:none">&#9632; Stop</button>' +
          '<button class="btn btn-muted" id="remote-mute" onclick="sendCommand(isMuted?\'unmute\':\'mute\')">Mute</button>' +
          '<button class="btn btn-muted" onclick="sendCommand(\'clear\')">Clear</button>' +
          '<button class="btn btn-muted" onclick="downloadTranscript(\'Remote download\')">&#8595; Download</button>' +
          '<button class="btn btn-muted" id="remote-follow" onclick="resumeAutoScroll()" title="Scroll to bottom &amp; resume following">&#8615; Follow</button>' +
          "</div>" +
          // Row 2: display + scroll controls
          '<div style="display:flex;align-items:center;gap:10px;flex-wrap:wrap">' +
          '<span class="control-label">Title</span>' +
          '<input type="text" id="remote-sermon-title-input" placeholder="Sermon title\u2026" oninput="setSermonTitle(this.value)">' +
          '<span class="control-label" style="margin-left:6px">Segment</span>' +
          '<select id="remote-chunk-ms" style="background:#111;border:1px solid #2a2a2a;border-radius:4px;padding:5px 8px;color:#fff;font-size:12px;cursor:pointer" onchange="sendCommand(\'setChunkMs\',this.value); pushTypoSync()">' +
          '<option value="20000">20s</option><option value="25000">25s</option><option value="30000" selected>30s</option>' +
          "</select>" +
          '<span class="control-label" style="margin-left:6px">Size</span>' +
          '<input type="range" class="slider" id="remote-font-slider" min="24" max="175" value="46" oninput="applyTypographyLocal(this.value,null,null);document.getElementById(\'remote-font-input\').value=this.value" onchange="applyTypography()" style="width:70px">' +
          '<input type="number" id="remote-font-input" min="24" max="175" value="46" oninput="applyTypographyLocal(this.value,null,null);document.getElementById(\'remote-font-slider\').value=this.value" onchange="applyTypography()" style="width:56px">' +
          '<span class="control-label">Line</span>' +
          '<input type="range" class="slider" id="remote-spacing-slider" min="12" max="150" value="20" oninput="applyTypographyLocal(null,this.value,null);document.getElementById(\'remote-spacing-input\').value=this.value" onchange="applyTypography()" style="width:70px">' +
          '<input type="number" id="remote-spacing-input" min="12" max="150" value="20" oninput="applyTypographyLocal(null,this.value,null);document.getElementById(\'remote-spacing-slider\').value=this.value" onchange="applyTypography()" style="width:56px">' +
          '<span class="control-label">Chunk</span>' +
          '<input type="range" class="slider" id="remote-chunk-spacing-slider" min="10" max="200" value="60" oninput="applyTypographyLocal(null,null,this.value);document.getElementById(\'remote-chunk-spacing-input\').value=this.value" onchange="applyTypography()" style="width:70px">' +
          '<input type="number" id="remote-chunk-spacing-input" min="10" max="200" value="60" oninput="applyTypographyLocal(null,null,this.value);document.getElementById(\'remote-chunk-spacing-slider\').value=this.value" onchange="applyTypography()" style="width:56px">' +
          '<span class="control-label">Scroll</span>' +
          '<input type="range" class="slider" id="remote-scroll-slider" min="40" max="500" value="70" oninput="scrollSpeed=parseInt(this.value);_lastLocalTypoTime=Date.now();document.getElementById(\'remote-scroll-input\').value=this.value" onchange="updateRemoteScrollSpeed(this.value)" style="width:70px">' +
          '<input type="number" id="remote-scroll-input" min="40" max="500" value="70" oninput="scrollSpeed=parseInt(this.value);_lastLocalTypoTime=Date.now();document.getElementById(\'remote-scroll-slider\').value=this.value" onchange="updateRemoteScrollSpeed(this.value)" style="width:56px">' +
          "</div>" +
          "</div>";
        document.body.appendChild(panel);

        // Keep main padding in sync with panel height when open
        var ro = new ResizeObserver(function () {
          if (remotePanelOpen) {
            document.getElementById("main").style.paddingTop =
              panel.offsetHeight + 8 + "px";
          }
        });
        ro.observe(panel);

        // Start polling
        pollRemote();
        setInterval(pollRemote, 1500);
      }

      // ════════════════════════════════════════════════════════════
      //  RECORDING — mic capture in configurable chunks (20/25/30s)
      //  Each chunk goes through: mute gate → size gate → queue → pipeline
      // ════════════════════════════════════════════════════════════
      async function startSession() {
        log("Requesting microphone...", "info");
        try {
          micStream = await navigator.mediaDevices.getUserMedia({
            audio: true,
          });
          log("Microphone granted.", "info");
        } catch (e) {
          log("Mic error: " + e.message, "err");
          toast("Microphone error: " + e.message);
          return;
        }
        isListening = true;
        document.getElementById("btn-start").style.display = "none";
        document.getElementById("btn-stop").style.display = "inline-block";
        document.getElementById("empty").style.display = "none";
        syncPopupState();
        pushSync("state", {
          isListening: true,
          isMuted: isMuted,
          chunkMs: parseInt(document.getElementById("chunk-ms").value),
        });
        log(
          "Remote: " + location.origin + location.pathname + "?remote",
          "info",
        );
        recordChunk();
      }

      function recordChunk() {
        if (!isListening) return;
        audioChunks = [];

        var mime = bestMime();
        var ms = parseInt(document.getElementById("chunk-ms").value);
        log("Recording " + ms / 1000 + "s...");

        try {
          mediaRecorder = mime
            ? new MediaRecorder(micStream, { mimeType: mime })
            : new MediaRecorder(micStream);
        } catch (_) {
          mediaRecorder = new MediaRecorder(micStream);
        }

        mediaRecorder.ondataavailable = function (e) {
          if (e.data && e.data.size > 0) audioChunks.push(e.data);
        };

        mediaRecorder.onstop = function () {
          if (isMuted) {
            audioChunks = [];
            if (isListening) recordChunk();
            return;
          }
          if (!audioChunks.length) {
            log("Empty chunk, skipping.", "warn");
            if (isListening) recordChunk();
            return;
          }
          var actualMime = mediaRecorder.mimeType || mime || "audio/webm";
          var blob = new Blob(audioChunks, { type: actualMime });
          log("Chunk: " + (blob.size / 1024).toFixed(1) + " KB", "info");
          if (blob.size < 8000) {
            log("Chunk too small (silence), skipping.", "warn");
            if (isListening) recordChunk();
            return;
          }
          queue.push(blob);
          processNext();
          if (isListening) recordChunk();
        };

        mediaRecorder.start(500);

        chunkTimer = setTimeout(function () {
          if (mediaRecorder && mediaRecorder.state === "recording")
            mediaRecorder.stop();
        }, ms);
      }

      var _cachedMime = null;
      function bestMime() {
        if (_cachedMime !== null) return _cachedMime;
        var types = [
          "audio/webm;codecs=opus",
          "audio/webm",
          "audio/ogg;codecs=opus",
          "audio/mp4",
        ];
        for (var i = 0; i < types.length; i++) {
          if (MediaRecorder.isTypeSupported(types[i])) {
            _cachedMime = types[i];
            return _cachedMime;
          }
        }
        _cachedMime = "";
        return _cachedMime;
      }

      var _stoppedAt = 0; // epoch when session was stopped — pipeline skips if started before this

      function stopSession() {
        isListening = false;
        _stoppedAt = Date.now();
        clearTimeout(chunkTimer);
        if (mediaRecorder && mediaRecorder.state !== "inactive")
          mediaRecorder.stop();
        if (micStream) {
          micStream.getTracks().forEach(function (t) {
            t.stop();
          });
          micStream = null;
        }

        // Flush pending queue so no more chunks enter the pipeline
        queue = [];
        updateQueueDepth();

        document.getElementById("btn-start").style.display = "inline-block";
        document.getElementById("btn-stop").style.display = "none";
        log("Stopped.");
        syncPopupState();

        // Wipe Redis after a short delay so any in-flight entry push lands first,
        // then the clear wipes it. 2s covers the worst-case render+push latency.
        setTimeout(function () {
          pushSync("clear", {
            chunkMs: parseInt(document.getElementById("chunk-ms").value),
            clearedAt: Date.now(),
          });
        }, 2000);
      }

      function clearAll() {
        document.getElementById("transcript").innerHTML = "";
        document.getElementById("log-entries").innerHTML = "";
        if (!sermonTitle) document.getElementById("empty").style.display = "";
        recentSegments = [];
        allSegments = [];
        sermonSummary = "";
        lastEnglishTail = "";
        if (consoleWindow && !consoleWindow.closed) {
          consoleWindow.document.getElementById("log-entries").innerHTML = "";
        }
        lastEditId = 0;
        syncPopupState();
        pushSync("clear", {
          chunkMs: parseInt(document.getElementById("chunk-ms").value),
          clearedAt: Date.now(),
        });
      }

      // ════════════════════════════════════════════════════════════
      //  DETACHABLE CONSOLE — pop-out admin window via window.open()
      //  Uses window.opener for direct cross-window function calls.
      //  Replays last 100 log entries on open; auto-reattaches on close.
      // ════════════════════════════════════════════════════════════
      function popOutConsole() {
        if (consoleWindow && !consoleWindow.closed) {
          consoleWindow.focus();
          return;
        }

        // Hide inline drawer first
        consoleOpen = false;
        document.getElementById("console-drawer").classList.remove("open");

        var popupHTML =
          "<!DOCTYPE html>\n" +
          '<html lang="en"><head><meta charset="UTF-8"><title>Admin Console</title>\n' +
          '<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400&display=swap" rel="stylesheet">\n' +
          "<style>\n" +
          "* { margin:0; padding:0; box-sizing:border-box; }\n" +
          "body { background:#0a0a0a; color:#fff; font-family:'Inter',system-ui,sans-serif; height:100vh; display:flex; flex-direction:column; overflow:hidden; }\n" +
          "#popup-header { display:flex; align-items:center; padding:12px 20px; border-bottom:1px solid #1a1a1a; flex-shrink:0; gap:10px; }\n" +
          "#popup-header > span:first-child { font-size:10px; letter-spacing:2px; text-transform:uppercase; color:#666; }\n" +
          "#popup-controls { display:flex; align-items:center; gap:10px; padding:14px 20px; border-bottom:1px solid #1a1a1a; flex-shrink:0; flex-wrap:wrap; }\n" +
          "select { background:#111; border:1px solid #2a2a2a; border-radius:4px; padding:7px 10px; color:#fff; font-family:'Inter',sans-serif; font-size:12px; outline:none; cursor:pointer; }\n" +
          ".btn { padding:7px 18px; border-radius:4px; border:1px solid #2a2a2a; font-family:'Inter',sans-serif; font-size:12px; cursor:pointer; transition:all 0.15s; white-space:nowrap; background:transparent; color:#fff; }\n" +
          ".btn-start { background:#fff; color:#000; border-color:#fff; } .btn-start:hover { background:#ddd; }\n" +
          ".btn-stop { color:#e55; border-color:#e55; } .btn-stop:hover { background:rgba(220,50,50,0.08); }\n" +
          ".btn-muted { color:#555; } .btn-muted:hover { color:#aaa; border-color:#666; }\n" +
          "#log-panel { flex:1; overflow-y:auto; padding:10px 20px; }\n" +
          "#log-panel::-webkit-scrollbar { width:2px; } #log-panel::-webkit-scrollbar-thumb { background:#222; }\n" +
          ".log { font-family:monospace; font-size:11px; line-height:1.8; color:#3a3; }\n" +
          ".log.err { color:#e55; } .log.warn { color:#b83; } .log.info { color:#48f; }\n" +
          "#queue-depth { font-size:10px; letter-spacing:1px; text-transform:uppercase; margin-left:auto; }\n" +
          "</style></head><body>\n" +
          '<div id="popup-header">\n' +
          "  <span>Admin Console</span>\n" +
          '  <span id="queue-depth"></span>\n' +
          '  <button class="btn btn-muted" style="padding:4px 10px;font-size:11px;margin-left:auto" onclick="reattach()">&#8601; Reattach</button>\n' +
          "</div>\n" +
          '<div id="popup-controls">\n' +
          '  <button class="btn btn-start" id="btn-start" onclick="window.opener.startSession()">&#9654; Begin</button>\n' +
          '  <button class="btn btn-stop"  id="btn-stop"  onclick="window.opener.stopSession()" style="display:none">&#9632; Stop</button>\n' +
          '  <button class="btn btn-muted" onclick="window.opener.clearAll()">Clear</button>\n' +
          '  <button class="btn btn-muted" onclick="window.opener.downloadTranscript(\'Manual download\')">&#8595; Download</button>\n' +
          '  <select id="chunk-ms" onchange="window.opener.document.getElementById(\'chunk-ms\').value = this.value">\n' +
          '    <option value="20000">20s</option><option value="25000">25s</option><option value="30000">30s</option>\n' +
          "  </select>\n" +
          "</div>\n" +
          '<div id="log-panel"><div id="log-entries"></div></div>\n' +
          "<script>\n" +
          "function reattach() {\n" +
          "  if (window.opener && !window.opener.closed) window.opener._reattachConsole();\n" +
          "  window.close();\n" +
          "}\n" +
          "function addLog(text, cls) {\n" +
          '  var wrap = document.getElementById("log-entries");\n' +
          '  var el = document.createElement("div");\n' +
          '  el.className = "log " + (cls || "");\n' +
          "  el.textContent = text;\n" +
          "  wrap.appendChild(el);\n" +
          "  while (wrap.children.length > 150) wrap.removeChild(wrap.firstChild);\n" +
          '  document.getElementById("log-panel").scrollTop = 99999;\n' +
          "}\n" +
          "function setQueue(n) {\n" +
          '  var el = document.getElementById("queue-depth");\n' +
          "  if (!el) return;\n" +
          '  el.textContent = n ? "Queue: " + n + " pending" : "";\n' +
          '  el.style.color = n > 2 ? "#e55" : "#b83";\n' +
          "}\n" +
          "function syncState(listening, chunkMs) {\n" +
          '  document.getElementById("btn-start").style.display = listening ? "none" : "inline-block";\n' +
          '  document.getElementById("btn-stop").style.display  = listening ? "inline-block" : "none";\n' +
          '  var sel = document.getElementById("chunk-ms");\n' +
          "  if (sel) sel.value = chunkMs;\n" +
          "}\n" +
          'window.addEventListener("beforeunload", function() {\n' +
          "  if (window.opener && !window.opener.closed) window.opener._reattachConsole();\n" +
          "});\n" +
          "<\/script></body></html>";

        consoleWindow = window.open(
          "",
          "AdminConsole",
          "width=720,height=520,resizable=yes",
        );
        if (!consoleWindow) {
          log("Popup blocked — allow popups for this site.", "err");
          return;
        }
        consoleWindow.document.write(popupHTML);
        consoleWindow.document.close();

        // Replay log history
        logHistory.forEach(function (entry) {
          consoleWindow.addLog(entry.text, entry.cls);
        });

        syncPopupState();
      }

      function _reattachConsole() {
        consoleWindow = null;
      }

      function syncPopupState() {
        if (!consoleWindow || consoleWindow.closed) return;
        var chunkMs = document.getElementById("chunk-ms").value;
        consoleWindow.syncState(isListening, chunkMs);
        consoleWindow.setQueue(queue.length);
      }

      // ════════════════════════════════════════════════════════════
      //  PIPELINE — sequential chunk processing
      //  Groq Whisper (KO speech-to-text) → hallucination filter
      //  → Claude Sonnet (KO→EN translation) → render + sync
      //  Chunks are processed one-at-a-time in FIFO order.
      // ════════════════════════════════════════════════════════════
      async function processNext() {
        updateQueueDepth();
        if (busy || !queue.length) return;
        busy = true;
        var blob = queue.shift();
        var chunkStarted = Date.now(); // track when this chunk entered the pipeline
        updateQueueDepth();

        try {
          // If session was stopped while we were queued, skip entirely
          if (_stoppedAt > chunkStarted) {
            busy = false;
            return;
          }

          log("Groq transcribing...");
          var korean = await groqTranscribe(blob);

          // If session was stopped during transcription, skip
          if (_stoppedAt > chunkStarted) {
            busy = false;
            return;
          }

          if (!korean || korean.trim().length < 3) {
            log("No speech detected.", "warn");
          } else if (isHallucination(korean)) {
            log(
              "Hallucination detected, skipping: " + korean.substring(0, 80),
              "warn",
            );
          } else {
            log(
              "KO: " +
                korean.substring(0, 80) +
                (korean.length > 80 ? "..." : ""),
              "info",
            );
            log("Claude translating...");
            var result = await claudeTranslate(korean);

            // If session was stopped during translation, skip render+push
            if (_stoppedAt > chunkStarted) {
              busy = false;
              return;
            }

            if (result.music) {
              log("Music detected: " + result.music, "info");
              renderMusic(result.music);
            } else {
              log(
                "EN: " +
                  result.english.substring(0, 80) +
                  (result.english.length > 80 ? "..." : ""),
                "info",
              );

              var seg = { korean: korean, english: result.english };
              recentSegments.push(seg);
              if (recentSegments.length > WINDOW_SIZE) recentSegments.shift();
              allSegments.push(seg);

              var sentences = result.english.match(/[^.!?]+[.!?]+/g) || [
                result.english,
              ];
              lastEnglishTail = sentences.slice(-3).join(" ").trim();

              renderEntry(result);

              if (allSegments.length % SUMMARY_EVERY === 0 && !summarizing) {
                generateSermonSummary();
              }
            }
          }
        } catch (e) {
          log("Error: " + e.message, "err");
          toast(e.message);
        }

        busy = false;
        updateQueueDepth();
        processNext();
      }

      // Whisper hallucinations repeat the same phrase many times (5+ occurrences).
      // Count every consecutive word-pair; flag if any bigram appears 3 or more times.
      // Using a threshold of 3 prevents false positives on naturally repeated phrases
      // like "the Lord" or "하나님이" which may legitimately appear twice in 30 s.
      function isHallucination(text) {
        var words = text.trim().split(/\s+/);
        if (words.length < 6) return false;
        var seen = {};
        for (var i = 0; i < words.length - 1; i++) {
          var bi = words[i] + "\x00" + words[i + 1];
          seen[bi] = (seen[bi] || 0) + 1;
          if (seen[bi] >= 5) return true;
        }
        return false;
      }

      // ════════════════════════════════════════════════════════════
      //  GROQ — Whisper Large v3 speech-to-text
      //  Sends base64 audio + previous Korean text as context prompt.
      //  No fallback keywords on first segment (causes hallucinations).
      //  Retries up to 3× with exponential backoff on failure.
      // ════════════════════════════════════════════════════════════
      async function groqTranscribe(blob) {
        var mimeMap = {
          "audio/webm": "webm",
          "audio/ogg": "ogg",
          "audio/mp4": "mp4",
          "audio/mpeg": "mp3",
          "audio/wav": "wav",
        };
        var baseMime = (blob.type || "audio/webm").split(";")[0];
        var ext = mimeMap[baseMime] || "webm";

        var audioBase64 = await new Promise(function (res, rej) {
          var reader = new FileReader();
          reader.onload = function () {
            res(reader.result.split(",")[1]);
          };
          reader.onerror = function () {
            rej(new Error("Failed to read audio"));
          };
          reader.readAsDataURL(blob);
        });

        // Seed Whisper with last known Korean text for domain vocabulary priming.
        // Falls back to core theological terms on the very first segment.
        // Use the previous segment's Korean as the Whisper context prompt.
        // No fallback keywords — sending domain terms to Whisper on silence
        // causes it to hallucinate those exact words back.
        var whisperPrompt = recentSegments.length
          ? recentSegments[recentSegments.length - 1].korean
              .replace(/[\r\n]+/g, " ")
              .trim()
              .slice(0, 400)
          : "";

        var lastErr;
        for (var attempt = 1; attempt <= 3; attempt++) {
          try {
            var controller = new AbortController();
            var timer = setTimeout(function () {
              controller.abort();
            }, 40000);
            var resp;
            try {
              resp = await fetch("/api/groq", {
                method: "POST",
                headers: authHeaders(),
                body: JSON.stringify({
                  audioBase64: audioBase64,
                  mimeType: baseMime,
                  ext: ext,
                  prompt: whisperPrompt,
                }),
                signal: controller.signal,
              });
            } finally {
              clearTimeout(timer);
            }
            if (!resp.ok) {
              var msg = "Groq HTTP " + resp.status;
              try {
                var j = await resp.json();
                msg = j.error || msg;
              } catch (_) {}
              throw new Error("Groq: " + msg);
            }
            return (await resp.text()).trim();
          } catch (e) {
            lastErr = e;
            if (attempt < 3) {
              log("Groq retry " + attempt + "...", "warn");
              await new Promise(function (r) {
                setTimeout(r, 1000 * attempt);
              });
            }
          }
        }
        throw lastErr;
      }

      // ════════════════════════════════════════════════════════════
      //  CLAUDE — Sonnet translation (KO → EN)
      //  Prompt includes: rolling sermon summary + last 3 translated
      //  segments for terminology consistency + tail of previous segment
      //  for cross-chunk sentence continuation. Retries 3× on failure.
      // ════════════════════════════════════════════════════════════
      // Assemble user prompt: summary (theme) + recent segments (terminology) + tail (continuity) + new Korean
      function buildPrompt(korean) {
        var p = "";
        if (sermonSummary) p += "SERMON SUMMARY:\n" + sermonSummary + "\n\n";
        if (recentSegments.length) {
          p += "RECENT TRANSCRIPT:\n";
          recentSegments.forEach(function (s, i) {
            p += "[" + (i + 1) + "] " + s.english + "\n";
          });
          p += "\n";
        }
        if (lastEnglishTail) {
          p +=
            'PREVIOUS SEGMENT ENDED WITH:\n"' +
            lastEnglishTail +
            '"\nIf this new Korean segment completes that thought, begin your translation with the continuation (e.g. the rest of the clause or sentence) — do NOT repeat or re-introduce what was already said. If it ends mid-clause without punctuation, your translation should flow on from it naturally.\n\n';
        }
        p += "NEW SEGMENT:\n" + korean;
        return p;
      }

      var SONNET_MODEL = "claude-sonnet-4-20250514";
      var HAIKU_MODEL = "claude-haiku-4-5-20251001";
      var _sonnetDown = false;

      async function claudeTranslate(korean) {
        var system =
          "You are a Korean-to-English translation assistant for a live Christian church service displayed on screen.\n\n" +
          "The microphone may pick up not just the pastor speaking, but also musical instruments (piano, guitar, organ, drums, etc.), or ambient sounds.\n\n" +
          "RULES:\n" +
          "1. If audio is not spoken korean such as instrumental or music then do not print anything. When in doubt, always translate — a missed translation is far less harmful than silently dropping real sermon content.\n" +
          "2. If the audio contains spoken Korean sermon content (even alongside music), translate it normally.\n" +
          "3. Translate naturally and fluently. No wooden or literal phrasing.\n" +
          "4. Use context to maintain consistent terminology and complete sentences cut off mid-thought.\n" +
          "5. Remove all filler words (um, uh, and Korean equivalents: \uc74c, \uc5b4, \uadf8, \uc774\uc81c, \uadf8\ub83c\uc11c, etc.) and stutters.\n" +
          "6. Preserve theological terms: \ud558\ub098\ub2d8\u2192God | \uc608\uc218\ub2d8\u2192Jesus Christ | \uc131\ub839\u2192the Holy Spirit | \uc8fc\ub2d8\u2192the Lord | \ub9d0\uc3f4\u2192the Word | \uc740\ud61c\u2192grace | \uad6c\uc6d0\u2192salvation | \uc2ed\uc790\uac00\u2192the cross | \ubd80\ud65c\u2192the resurrection | \ubbf8\ub364\u2192faith | \uae30\ub3c4\u2192prayer\n" +
          "7. Convert Korean Bible references: \uc694\ud55c\ubcf5\uc74c 3\uc7a5 16\uc808\u2192John 3:16 | \uc2dc\ud3b8 23\ud3b8\u2192Psalm 23\n" +
          "8. Never begin the translation with a closing quotation mark or apostrophe. Audio is split into chunks mid-speech — if the previous chunk ended mid-quote, continue naturally without any opening quote marker.\n\n" +
          "9. The church name is 'The Lord's Church' located in Iselin, New Jersey and the head pastor is 'Kim Nam Soo' and the regular pastor is 'Chun Min Sung'. If relevant, you can include them in the translation for clarity and naturalness, but they are not required to be mentioned in every segment.\n\n" +
          "Respond ONLY in valid JSON, no markdown:\n" +
          'For speech: {"english":"translated text","scripture":[{"ref":"John 3:16","note":""}]}\n' +
          'For music only: {"music":"description of what is playing"}';

        var prompt = buildPrompt(korean);

        // Single fetch to Claude with a given model
        async function tryModel(model) {
          var controller = new AbortController();
          var timer = setTimeout(function () { controller.abort(); }, 30000);
          var resp;
          try {
            resp = await fetch("/api/claude", {
              method: "POST",
              headers: authHeaders(),
              body: JSON.stringify({
                model: model,
                max_tokens: 400,
                temperature: 0,
                system: system,
                messages: [{ role: "user", content: prompt }],
              }),
              signal: controller.signal,
            });
          } finally {
            clearTimeout(timer);
          }

          if (!resp.ok) {
            var msg = "Claude HTTP " + resp.status;
            var isOverloaded = resp.status === 529 || resp.status === 504;
            try {
              var j = await resp.json();
              msg = j.error?.message || msg;
              if (msg.toLowerCase().indexOf("overloaded") !== -1) isOverloaded = true;
            } catch (_) {}
            var err = new Error("Claude: " + msg);
            err.overloaded = isOverloaded;
            throw err;
          }

          var data = await resp.json();
          var raw = data.content
            .map(function (b) { return b.text || ""; })
            .join("")
            .trim();
          try {
            return JSON.parse(
              raw.replace(/^```json\n?|^```\n?|\n?```$/gm, "").trim(),
            );
          } catch (_) {
            return { english: raw, scripture: [] };
          }
        }

        // Always try Sonnet first — even if previously down, to detect recovery
        var lastErr;
        for (var attempt = 1; attempt <= 3; attempt++) {
          try {
            var result = await tryModel(SONNET_MODEL);
            if (_sonnetDown) {
              _sonnetDown = false;
              log("Sonnet is back \u2014 resuming primary model.", "info");
            }
            return result;
          } catch (e) {
            lastErr = e;
            if (attempt < 3) {
              log("Retry " + attempt + "...", "warn");
              await new Promise(function (r) { setTimeout(r, 1500 * attempt); });
            }
          }
        }

        // Sonnet failed 3 times — fall back to Haiku
        _sonnetDown = true;
        log("Sonnet overloaded \u2014 falling back to Haiku.", "warn");

        for (var hAttempt = 1; hAttempt <= 2; hAttempt++) {
          try {
            return await tryModel(HAIKU_MODEL);
          } catch (e) {
            lastErr = e;
            if (hAttempt < 2) {
              log("Haiku retry...", "warn");
              await new Promise(function (r) { setTimeout(r, 1500); });
            }
          }
        }

        throw lastErr;
      }

      // ════════════════════════════════════════════════════════════
      //  BACKGROUND SUMMARY
      //  Every SUMMARY_EVERY segments, Haiku produces a rolling 3-sentence
      //  summary. Uses incremental approach: sends previous summary + only
      //  the latest batch of segments (not the entire transcript), so Haiku
      //  input stays ~constant regardless of sermon length.
      // ════════════════════════════════════════════════════════════
      async function generateSermonSummary() {
        summarizing = true;
        log("Updating sermon summary...", "info");

        // Only send the latest batch, not the entire sermon
        var startIdx = Math.max(0, allSegments.length - SUMMARY_EVERY);
        var recentTranscript = allSegments
          .slice(startIdx)
          .map(function (s, i) {
            return "[" + (startIdx + i + 1) + "] " + s.english;
          })
          .join("\n");

        // First summary: cold start. Later summaries: build on the previous one.
        var prompt = sermonSummary
          ? "Here is your previous summary of this sermon:\n" +
            sermonSummary +
            "\n\nHere are the newest segments:\n" +
            recentTranscript +
            "\n\nUpdate your summary to incorporate the new content. Keep it to 3 sentences covering: main theme, key points, central scriptures, direction. Plain prose only."
          : "Summarize this Christian sermon in 3 sentences for a translation assistant. Cover: main theme, key points, central scriptures, direction. Plain prose only.\n\n" +
            recentTranscript;

        try {
          var controller = new AbortController();
          var timer = setTimeout(function () {
            controller.abort();
          }, 20000);
          var resp;
          try {
            resp = await fetch("/api/claude", {
              method: "POST",
              headers: authHeaders(),
              body: JSON.stringify({
                model: "claude-haiku-4-5-20251001",
                max_tokens: 200,
                temperature: 0,
                messages: [{ role: "user", content: prompt }],
              }),
              signal: controller.signal,
            });
          } finally {
            clearTimeout(timer);
          }
          if (resp.ok) {
            var data = await resp.json();
            sermonSummary = data.content
              .map(function (b) {
                return b.text || "";
              })
              .join("")
              .trim();
            log("Summary updated.", "info");
          }
        } catch (e) {
          log("Summary failed: " + e.message, "warn");
        }
        summarizing = false;
      }

      // ════════════════════════════════════════════════════════════
      //  DOWNLOAD TRANSCRIPT
      // ════════════════════════════════════════════════════════════
      function downloadTranscript(reason) {
        var transcriptEl = document.getElementById("transcript");
        var entries = transcriptEl.querySelectorAll(".entry, .music-label");
        if (!entries.length) return;

        var date = new Date().toLocaleDateString("en-US", {
          weekday: "long",
          year: "numeric",
          month: "long",
          day: "numeric",
        });
        var time = new Date().toLocaleTimeString("en-US", {
          hour: "2-digit",
          minute: "2-digit",
        });

        var lines = [];
        lines.push("SERMON TRANSCRIPT");
        lines.push(date + " at " + time);
        if (reason) lines.push("(" + reason + ")");
        lines.push("");
        lines.push("─".repeat(60));
        lines.push("");

        var segCount = 0;
        entries.forEach(function (el) {
          if (el.classList.contains("music-label")) {
            lines.push("\u266a " + el.textContent.trim());
            lines.push("");
          } else {
            var spans = el.querySelectorAll(".sentence");
            if (spans.length) {
              var text = Array.from(spans)
                .map(function (s) {
                  return s.textContent.trim();
                })
                .join(" ");
              lines.push(text);
              lines.push("");
              segCount++;
            }
          }
        });

        lines.push("─".repeat(60));
        lines.push(segCount + " segments transcribed.");

        var blob = new Blob([lines.join("\n")], {
          type: "text/plain;charset=utf-8",
        });
        var url = URL.createObjectURL(blob);
        var a = document.createElement("a");
        var filename =
          "sermon-" + new Date().toISOString().slice(0, 10) + ".txt";
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);
        log("Transcript downloaded: " + filename, "info");
      }

      // ════════════════════════════════════════════════════════════
      //  RENDER — display translated text on screen
      //  Splits English into sentences, highlights scripture refs,
      //  makes each sentence contenteditable for inline corrections.
      //  Pushes each entry to Redis for phone sync.
      // ════════════════════════════════════════════════════════════
      function renderMusic(description) {
        var wrap = document.getElementById("transcript");
        var label = document.createElement("div");
        label.className = "music-label";
        label.textContent = description;
        wrap.appendChild(label);
        scrollToBottom();
        pushSync("entry", {
          id: Date.now(),
          type: "music",
          description: description,
        });
      }

      function renderEntry(result) {
        var entryId = Date.now();
        var wrap = document.getElementById("transcript");
        var entry = document.createElement("div");
        entry.className = "entry";
        entry.dataset.entryId = String(entryId);

        // Split english into individual sentences for easier reading
        // Strip leading quote/apostrophe artifacts from chunk-boundary continuation
        var englishText = (result.english || "").replace(
          /^[\s\u0027\u0022\u2018\u2019\u201C\u201D]+/,
          "",
        );
        var rawSentences = englishText.match(/[^.!?]+[.!?]*/g) || [englishText];
        // Filter out empty strings and strip leading quote/apostrophe artifacts from each sentence
        var sentences = rawSentences
          .map(function (s) {
            return s.replace(/^[\s\u0027\u0022\u2018\u2019\u201C\u201D]+/, "");
          })
          .filter(function (s) {
            return s.trim().length > 0;
          });

        var sentencesHTML = sentences
          .map(function (s) {
            var escaped = esc(s.trim());
            // Highlight any scripture refs inline
            if (result.scripture && result.scripture.length) {
              result.scripture.forEach(function (sc) {
                if (!sc.ref) return;
                var safe = sc.ref.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
                escaped = escaped.replace(
                  new RegExp(safe, "g"),
                  '<span style="color:#666;border-bottom:1px solid #2a2a2a">' +
                    sc.ref +
                    "</span>",
                );
              });
            }
            return (
              '<span class="sentence" contenteditable="true">' +
              escaped +
              "</span>"
            );
          })
          .join("");

        var scriptureBlocks = (result.scripture || [])
          .filter(function (s) {
            return s.ref;
          })
          .map(function (s) {
            return (
              '<span class="scripture-callout">(' +
              esc(s.ref) +
              (s.note ? " \u2014 " + esc(s.note) : "") +
              ")</span>"
            );
          })
          .join("");

        entry.innerHTML = sentencesHTML + scriptureBlocks;

        wrap.appendChild(entry);
        addEditListeners(entry, entryId);
        scrollToBottom();
        pushSync("entry", {
          id: entryId,
          type: "entry",
          sentences: sentences.map(function (s) {
            return s.trim();
          }),
          scripture: result.scripture || [],
        });
      }

      function esc(s) {
        return String(s)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;");
      }

      // ════════════════════════════════════════════════════════════
      //  TYPOGRAPHY CONTROLS — dual slider + number input
      //  oninput: live CSS preview + extend grace period (no Redis push)
      //  onchange: commit to CSS + push to Redis for cross-device sync
      // ════════════════════════════════════════════════════════════

      // Live preview only (oninput) — no Redis push.
      // Also extends the grace period so pollRemote can't overwrite an in-progress drag.
      function applyTypographyLocal(fs, lh, cs) {
        _lastLocalTypoTime = Date.now();
        if (fs !== null && fs !== undefined)
          document.documentElement.style.setProperty(
            "--sentence-size",
            parseInt(fs) + "px",
          );
        if (lh !== null && lh !== undefined)
          document.documentElement.style.setProperty(
            "--sentence-spacing",
            parseInt(lh) + "px",
          );
        if (cs !== null && cs !== undefined)
          document.documentElement.style.setProperty(
            "--chunk-spacing",
            parseInt(cs) + "px",
          );
      }

      // Commit (onchange) — applies CSS vars + pushes to Redis.
      // Must prefer the ACTIVE device's input — on remote, the hidden
      // laptop inputs still exist in the DOM with stale default values.
      function applyTypography() {
        var fsEl = isRemote
          ? document.getElementById("remote-font-input") ||
            document.getElementById("font-size-input")
          : document.getElementById("font-size-input") ||
            document.getElementById("remote-font-input");
        var lhEl = isRemote
          ? document.getElementById("remote-spacing-input") ||
            document.getElementById("line-height-input")
          : document.getElementById("line-height-input") ||
            document.getElementById("remote-spacing-input");
        var csEl = isRemote
          ? document.getElementById("remote-chunk-spacing-input") ||
            document.getElementById("chunk-spacing-input")
          : document.getElementById("chunk-spacing-input") ||
            document.getElementById("remote-chunk-spacing-input");
        var fontSize = fsEl ? parseInt(fsEl.value) : 46;
        var lineHeight = lhEl ? parseInt(lhEl.value) : 20;
        var chunkSpacing = csEl ? parseInt(csEl.value) : 60;

        document.documentElement.style.setProperty(
          "--sentence-size",
          fontSize + "px",
        );
        document.documentElement.style.setProperty(
          "--sentence-spacing",
          lineHeight + "px",
        );
        document.documentElement.style.setProperty(
          "--chunk-spacing",
          chunkSpacing + "px",
        );
        pushTypoSync();
      }

      // Init CSS vars on load; block Enter inside editable sentences
      document.addEventListener("DOMContentLoaded", function () {
        document
          .getElementById("transcript")
          .addEventListener("keydown", function (e) {
            if (e.key === "Enter") e.preventDefault();
          });

        // Smart scroll detection — disable auto-follow when user scrolls up
        (function () {
          var main = document.getElementById("main");
          var _sct = null;

          main.addEventListener("scroll", function () {
            if (_scrollLock) return; // our own animation — ignore
            clearTimeout(_sct);
            _sct = setTimeout(function () {
              var atBot =
                main.scrollHeight - main.scrollTop - main.clientHeight < 80 ||
                (_scrollTarget > 0 &&
                  Math.abs(main.scrollTop - _scrollTarget) < 80);
              if (autoScroll !== atBot) {
                autoScroll = atBot;
                updateFollowBtn();
                // User scrolled back to bottom — restart the teleprompter
                if (atBot) scrollToBottom();
              }
            }, 120);
          });

          // User intentionally scrolling — cancel animation immediately
          main.addEventListener("wheel", cancelScrollAnim, { passive: true });
          main.addEventListener("touchstart", cancelScrollAnim, {
            passive: true,
          });
        })();

        if (isRemote) {
          initRemote();
        } else {
          applyTypography();
          setInterval(pollCommands, 3000);
        }
      });

      // ════════════════════════════════════════════════════════════
      //  RESIZE CONSOLE DRAWER
      // ════════════════════════════════════════════════════════════
      (function () {
        var handle = document.getElementById("resize-handle");
        var drawer = document.getElementById("console-drawer");
        var startY = 0;
        var startH = 0;
        var dragging = false;

        handle.addEventListener("mousedown", function (e) {
          dragging = true;
          startY = e.clientY;
          startH = drawer.offsetHeight;
          document.body.style.userSelect = "none";
          e.preventDefault();
        });

        document.addEventListener("mousemove", function (e) {
          if (!dragging) return;
          var delta = startY - e.clientY; // drag up = bigger
          var newH = Math.min(
            Math.max(startH + delta, 160),
            window.innerHeight * 0.9,
          );
          drawer.style.height = newH + "px";
        });

        document.addEventListener("mouseup", function () {
          dragging = false;
          document.body.style.userSelect = "";
        });

        // Touch support
        handle.addEventListener(
          "touchstart",
          function (e) {
            dragging = true;
            startY = e.touches[0].clientY;
            startH = drawer.offsetHeight;
            e.preventDefault();
          },
          { passive: false },
        );

        document.addEventListener(
          "touchmove",
          function (e) {
            if (!dragging) return;
            var delta = startY - e.touches[0].clientY;
            var newH = Math.min(
              Math.max(startH + delta, 160),
              window.innerHeight * 0.9,
            );
            drawer.style.height = newH + "px";
          },
          { passive: true },
        );

        document.addEventListener("touchend", function () {
          dragging = false;
        });
      })();
    </script>
  </body>
</html>
